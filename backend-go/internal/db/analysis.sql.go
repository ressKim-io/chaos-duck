// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: analysis.sql

package db

import (
	"context"
	"encoding/json"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalysisResult = `-- name: CreateAnalysisResult :one
INSERT INTO analysis_results (experiment_id, severity, root_cause, confidence, recommendations, resilience_score)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, experiment_id, severity, root_cause, confidence, recommendations, resilience_score, created_at
`

type CreateAnalysisResultParams struct {
	ExperimentID    string          `json:"experiment_id"`
	Severity        string          `json:"severity"`
	RootCause       string          `json:"root_cause"`
	Confidence      float64         `json:"confidence"`
	Recommendations json.RawMessage `json:"recommendations"`
	ResilienceScore pgtype.Float8   `json:"resilience_score"`
}

func (q *Queries) CreateAnalysisResult(ctx context.Context, arg CreateAnalysisResultParams) (AnalysisResult, error) {
	row := q.db.QueryRow(ctx, createAnalysisResult,
		arg.ExperimentID,
		arg.Severity,
		arg.RootCause,
		arg.Confidence,
		arg.Recommendations,
		arg.ResilienceScore,
	)
	var i AnalysisResult
	err := row.Scan(
		&i.ID,
		&i.ExperimentID,
		&i.Severity,
		&i.RootCause,
		&i.Confidence,
		&i.Recommendations,
		&i.ResilienceScore,
		&i.CreatedAt,
	)
	return i, err
}

const getAnalysisResultsByExperiment = `-- name: GetAnalysisResultsByExperiment :many
SELECT id, experiment_id, severity, root_cause, confidence, recommendations, resilience_score, created_at FROM analysis_results WHERE experiment_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetAnalysisResultsByExperiment(ctx context.Context, experimentID string) ([]AnalysisResult, error) {
	rows, err := q.db.Query(ctx, getAnalysisResultsByExperiment, experimentID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalysisResult{}
	for rows.Next() {
		var i AnalysisResult
		if err := rows.Scan(
			&i.ID,
			&i.ExperimentID,
			&i.Severity,
			&i.RootCause,
			&i.Confidence,
			&i.Recommendations,
			&i.ResilienceScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnalysisResultsSince = `-- name: ListAnalysisResultsSince :many
SELECT id, experiment_id, severity, root_cause, confidence, recommendations, resilience_score, created_at FROM analysis_results
WHERE created_at >= $1
ORDER BY created_at ASC
`

func (q *Queries) ListAnalysisResultsSince(ctx context.Context, createdAt pgtype.Timestamptz) ([]AnalysisResult, error) {
	rows, err := q.db.Query(ctx, listAnalysisResultsSince, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalysisResult{}
	for rows.Next() {
		var i AnalysisResult
		if err := rows.Scan(
			&i.ID,
			&i.ExperimentID,
			&i.Severity,
			&i.RootCause,
			&i.Confidence,
			&i.Recommendations,
			&i.ResilienceScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAnalysisResultsSinceByNamespace = `-- name: ListAnalysisResultsSinceByNamespace :many
SELECT ar.id, ar.experiment_id, ar.severity, ar.root_cause, ar.confidence, ar.recommendations, ar.resilience_score, ar.created_at FROM analysis_results ar
JOIN experiments e ON ar.experiment_id = e.id
WHERE ar.created_at >= $1
  AND e.config->>'target_namespace' = $2::text
ORDER BY ar.created_at ASC
`

type ListAnalysisResultsSinceByNamespaceParams struct {
	Since     pgtype.Timestamptz `json:"since"`
	Namespace string             `json:"namespace"`
}

func (q *Queries) ListAnalysisResultsSinceByNamespace(ctx context.Context, arg ListAnalysisResultsSinceByNamespaceParams) ([]AnalysisResult, error) {
	rows, err := q.db.Query(ctx, listAnalysisResultsSinceByNamespace, arg.Since, arg.Namespace)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []AnalysisResult{}
	for rows.Next() {
		var i AnalysisResult
		if err := rows.Scan(
			&i.ID,
			&i.ExperimentID,
			&i.Severity,
			&i.RootCause,
			&i.Confidence,
			&i.Recommendations,
			&i.ResilienceScore,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
